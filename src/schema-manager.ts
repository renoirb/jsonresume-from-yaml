/**
 *  Read and walk all YAML files in a directory
 */

import { compile as generateTypings } from 'json-schema-to-typescript';
// @ts-ignore
import { schema } from 'resume-schema';
import YAML from 'yaml';
// z-schema should be at the same version as jsonResumeSchema
import { default as SchemaValidator, Options as SchemaOptions } from 'z-schema';

const validatorOptions: Partial<SchemaOptions> = {
  // Nothing to put in there, for now.
  breakOnFirstError: true,
  ignoreUnknownFormats: true,
};

/**
 * JSON Schema and Typings comment at the top of the file.
 */
const bannerComment: string = `
/**
 * JSONResume schema
 *
 * ==================== DO NOT MODIFY IT BY HAND ====================
 * This file was automatically generated by json-schema-to-typescript
 * for JSONResume schema.
 *
 * If you need to change schema, generate another version using
 * SchemaManager.
 *
 * {@link SchemaManager.generateTypingsFileContents}
 */
`;

/**
 * Schema Manager.
 *
 * Manages current JSONResume JSONSchema typings and
 * ensures validity of input for usage within the factory.
 *
 * This class should be generic enough to be used for other schemas.
 *
 * NOTE: This might be used as well for any other type of project
 * where one would want to take a JSON Schema, and be able to use
 * a directory of YAML files to manage generate a matching JSON file.
 *
 * But, for now, this is usable only for JSONResume.
 * We could eventually factor this out as a separate module.
 *
 * @public
 */
export class SchemaManager {
  private readonly sections: { [name: string]: string[] } = {};
  private validator: SchemaValidator = new SchemaValidator(validatorOptions);

  constructor(private readonly schemasString: string = '') {
    const isEmptyCtorSchema = schemasString === '';
    const stringifiedFallbackSchema = JSON.stringify(schema);
    const applicableSchemaString = isEmptyCtorSchema
      ? stringifiedFallbackSchema
      : schemasString;

    const schemas = [
      {
        ...JSON.parse(applicableSchemaString),
      },
    ];
    if (!schemas[0].id) {
      schemas[0].id = 'ResumeSchema';
    }
    const firstSchemaHashMap = schemas[0];
    const allSchemasValid = this.validator.validateSchema(
      JSON.parse(JSON.stringify(schemas)),
    );
    const errors = this.validator.getLastErrors();
    if (!allSchemasValid) {
      let message = `JSONSchema could not import schema`;
      if (errors) {
        message += `\n${JSON.stringify(errors)}\n\n`;
      }
      throw new Error(message);
    }
    this.schemasString = JSON.stringify(schemas);
    this.sections[firstSchemaHashMap.id] = [];
    if ('properties' in firstSchemaHashMap) {
      for (const [propName] of Object.entries(firstSchemaHashMap.properties)) {
        this.sections[firstSchemaHashMap.id].push(propName);
      }
    } else {
      const message = 'Invalid schema provided';
      throw new Error(message);
    }
  }

  public get schemaNames(): string[] {
    const schemas = JSON.parse(this.schemasString);
    // tslint:disable-next-line:no-any
    const keys = schemas.map((s: any) => s.id);
    return keys;
  }

  // tslint:disable-next-line: no-any
  public getSchema(schemaName: string): any {
    const schemaNames = [...this.schemaNames];
    const hasSchema = schemaNames.includes(schemaName);
    if (!hasSchema) {
      const message = `Schema "${schemaName} not found, currently supported: ${schemaNames}`;
      throw new Error(message);
    }
    const schemas = JSON.parse(this.schemasString);
    const maybeSchema = schemas.filter(
      // tslint:disable-next-line: no-any
      (item: any): boolean => Reflect.has(item, 'id') && item.id === schemaName,
    );
    if (!maybeSchema) {
      const message = `Schema "${schemaName} not found, currently supported: ${schemaNames}`;
      throw new Error(message);
    } else {
      return schema;
    }
  }

  // tslint:disable-next-line:no-any
  public get schemas(): any[] {
    const schemas = JSON.parse(this.schemasString);
    return schemas;
  }

  public get foo(): string {
    return this.schemasString;
  }

  /**
   * Validate an hydrated resume object against schema validator
   * https://github.com/zaggino/z-schema/blob/master/index.d.ts#L89
   */
  // tslint:disable-next-line:no-any
  public validate(schemaName: string, dto: any): boolean {
    // const schemaDesc = this.getSchema(schemaName);
    // const schemaDesc = JSON.parse(this.schemasString);
    // return this.validator.validate(dto, schemaDesc[0]);
    return this.validator.validate(dto, schemaName);
  }

  /**
   * Take YAML contents convert into JSON string ONLY IF it is valid.
   *
   * @param {string} section Name of the section
   * @param {string} contents YAML contents to be convert into a JSON string
   * @returns {String|null} JSON string to be imported into the entity with matching section name.
   */
  public parse(schemaName: string, section: string, contents: string): string {
    let errorMessage = '';
    if (!(schemaName in this.sections)) {
      errorMessage = `No schema stored for "${schemaName}.`;
      throw new Error(errorMessage);
    }
    const sections = this.sections[schemaName];

    errorMessage = `Invalid top level section "${section}" provided, it is not part of the schema;`;
    if (!sections.includes(section)) {
      const keys = sections.join(', ');
      errorMessage += ` only the following are accepted: ${keys}`;
      throw new Error(errorMessage);
    }

    const parsed = YAML.parse(contents);
    const isValid = this.validate(schemaName, { [section]: parsed });
    const errors = this.validator.getLastErrors();
    if (errors) {
      errorMessage += `\n${YAML.stringify(errors)}\n`;
    }
    if (!isValid) {
      errorMessage += ` the contents has inconsistencies with the schema.`;
      throw new Error(errorMessage);
    }

    const stringified = JSON.stringify(parsed);
    return stringified;
  }

  /**
   * Based on the currently loaded JSONSchema,
   * generate a TypeScript typings file.
   * This is useful to write a new version of a schema.
   *
   * https://github.com/bcherny/json-schema-to-typescript
   */
  public async generateTypingsFileContents(
    schemaName: string,
  ): Promise<string> {
    // rel=#DeclareExtendZSchemaTypings in types.d.ts `declare module 'z-schema'`
    // @ts-ignore
    const schemaDesc = this.validator.getResolvedSchema(schemaName);
    return generateTypings(schemaDesc, schemaName, { bannerComment });
  }
}
